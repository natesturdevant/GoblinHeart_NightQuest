<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goblinheart Story Editor - VHS Example</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Press Start 2P', monospace;
            background-color: #000;
            color: #0f0;
            font-size: 10px;
            line-height: 1.6;
        }
        
        h1 {
            text-align: center;
            color: #0ff;
            font-size: 16px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #055;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }
        
        .panel {
            background-color: #001;
            border: 2px solid #0f0;
            padding: 15px;
        }
        
        .panel h2 {
            font-size: 11px;
            color: #0ff;
            margin: 0 0 15px 0;
            border-bottom: 1px solid #0f0;
            padding-bottom: 8px;
        }
        
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .tab {
            flex: 1;
            padding: 8px;
            background-color: #002;
            border: 2px solid #050;
            cursor: pointer;
            font-size: 7px;
            text-align: center;
            color: #0a0;
        }
        
        .tab:hover {
            background-color: #003;
            border-color: #0a0;
        }
        
        .tab.active {
            background-color: #004;
            border-color: #0ff;
            color: #0ff;
        }
        
        .node-list {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .node-item {
            padding: 8px;
            margin: 5px 0;
            background-color: #002;
            border: 1px solid #050;
            cursor: pointer;
            font-size: 8px;
        }
        
        .node-item:hover {
            background-color: #003;
            border-color: #0a0;
        }
        
        .node-item.selected {
            background-color: #004;
            border: 2px solid #0ff;
        }
        
        .node-type-badge {
            display: inline-block;
            padding: 2px 6px;
            font-size: 6px;
            border-radius: 3px;
            margin-right: 5px;
        }
        
        .badge-dialogue { background: #004; color: #0ff; border: 1px solid #0ff; }
        .badge-event { background: #400; color: #ff0; border: 1px solid #ff0; }
        .badge-quest { background: #040; color: #0f0; border: 1px solid #0f0; }
        
        .button {
            background-color: #003;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 8px 15px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
        }
        
        .button:hover {
            background-color: #005;
            border-color: #0ff;
        }
        
        .button.danger {
            border-color: #f00;
            color: #f00;
        }
        
        .button.danger:hover {
            background-color: #300;
        }
        
        .button.primary {
            background-color: #030;
            border-color: #0ff;
            color: #0ff;
        }
        
        input, textarea, select {
            width: 100%;
            background-color: #001;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            margin: 5px 0;
        }
        
        input[type="number"] {
            width: 100px;
        }
        
        input[type="checkbox"] {
            width: auto;
        }
        
        label {
            display: block;
            color: #ff0;
            font-size: 8px;
            margin: 10px 0 5px 0;
        }
        
        .inline-label {
            display: inline;
            margin-left: 5px;
        }
        
        .section {
            margin: 15px 0;
            padding: 12px;
            background-color: #002;
            border: 1px solid #0a0;
        }
        
        .section-title {
            color: #0ff;
            font-size: 9px;
            margin-bottom: 10px;
            border-bottom: 1px solid #050;
            padding-bottom: 5px;
        }
        
        .condition-block, .action-block {
            background-color: #001;
            border: 1px solid #050;
            padding: 10px;
            margin: 8px 0;
            position: relative;
        }
        
        .block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #030;
        }
        
        .block-number {
            color: #ff0;
            font-size: 8px;
        }
        
        .small-button {
            padding: 4px 8px;
            font-size: 7px;
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .export-area {
            margin-top: 20px;
        }
        
        textarea.export {
            min-height: 200px;
            font-family: 'Courier New', monospace;
            font-size: 9px;
        }
        
        .help {
            background-color: #002;
            border: 1px solid #050;
            padding: 10px;
            margin: 15px 0;
            font-size: 7px;
            color: #888;
            line-height: 1.8;
        }
        
        .empty-state {
            text-align: center;
            color: #555;
            padding: 40px;
            font-size: 9px;
        }
        
        .flow-preview {
            background-color: #002;
            border: 2px solid #0a0;
            padding: 15px;
            margin: 15px 0;
            font-size: 7px;
            color: #888;
        }
        
        .flow-node {
            background-color: #001;
            border: 1px solid #050;
            padding: 8px;
            margin: 5px 0;
            margin-left: 20px;
            border-left: 2px solid #0ff;
        }
        
        .flow-condition {
            color: #ff0;
            font-size: 6px;
        }
        
        .flow-action {
            color: #0f0;
            font-size: 6px;
        }
    </style>
</head>
<body>
    <h1>GOBLINHEART STORY EDITOR - VHS EXAMPLE</h1>
    
    <div class="help" style="max-width: 1600px; margin: 0 auto 20px auto;">
        <strong style="color: #0ff;">ðŸ‘‹ EXAMPLE LOADED!</strong><br>
        This editor is pre-populated with the VHS transport sequence from your game.<br>
        <strong style="color: #ff0;">Try this:</strong><br>
        1. Click on "eddie_video_clerk" to see an NPC with conditional dialogue<br>
        2. Click on "vhs_appears" to see a scripted event with triggers<br>
        3. Click on "vhs_transport" to see the transport sequence<br>
        4. Click "ðŸ’¾ DOWNLOAD ALL" to generate working dialogue.js and events.js files!
    </div>
    
    <div class="container">
        <!-- Left Panel: Node List -->
        <div class="panel">
            <h2>STORY NODES</h2>
            
            <div class="tabs">
                <div class="tab active" data-tab="all">ALL</div>
                <div class="tab" data-tab="dialogue">NPCS</div>
                <div class="tab" data-tab="event">EVENTS</div>
                <div class="tab" data-tab="quest">QUESTS</div>
            </div>
            
            <div class="button-row">
                <button class="button small-button" onclick="addNode('dialogue')">+ NPC</button>
                <button class="button small-button" onclick="addNode('event')">+ EVENT</button>
                <button class="button small-button" onclick="addNode('quest')">+ QUEST</button>
            </div>
            
            <button class="button danger small-button" onclick="deleteNode()" style="width: 100%;">DELETE NODE</button>
            
            <div class="node-list" id="nodeList"></div>
            
            <div class="export-area">
                <h2>EXPORT</h2>
                <button class="button primary" onclick="downloadAll()">ðŸ’¾ DOWNLOAD ALL</button>
                <button class="button" onclick="exportJSON()">EXPORT JSON</button>
                <button class="button" onclick="importJSON()">IMPORT JSON</button>
                <textarea class="export" id="exportArea" placeholder="JSON will appear here..."></textarea>
            </div>
        </div>
        
        <!-- Right Panel: Node Editor -->
        <div class="panel">
            <div id="editorArea">
                <div class="empty-state">
                    ðŸ‘ˆ Click on a story node to see how it's configured!<br><br>
                    Start with "eddie_video_clerk" to see NPC dialogue.
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== PRE-POPULATED DATA WITH VHS SEQUENCE =====
        let storyData = {
            nodes: {
                // ===== NPC: EDDIE (Video Store Clerk) =====
                'eddie_video_clerk': {
                    type: 'dialogue',
                    name: 'Eddie',
                    sprite: 'villager_worker',
                    isShopkeeper: false,
                    dialogueLines: [
                        {
                            id: 'default',
                            text: 'Hey! Ready for another shift?',
                            triggers: [],
                            actions: []
                        },
                        {
                            id: 'vhs_comment',
                            text: "Someone returned that tape this morning. Never seen one like it. Weird symbols and all. Check if it's damaged, will ya?",
                            triggers: [
                                { type: 'flag', flagName: 'vhsAppeared', shouldBe: 'true' },
                                { type: 'flag', flagName: 'eddieCommentedOnVHS', shouldBe: 'false' }
                            ],
                            actions: [
                                { type: 'setFlag', flagName: 'eddieCommentedOnVHS', value: 'true' }
                            ]
                        },
                        {
                            id: 'after_vhs',
                            text: 'Find anything wrong with that weird tape?',
                            triggers: [
                                { type: 'flag', flagName: 'eddieCommentedOnVHS', shouldBe: 'true' }
                            ],
                            actions: []
                        }
                    ]
                },
                
                // ===== EVENT: VHS APPEARS AT VIDEO STORE =====
                'vhs_appears': {
                    type: 'event',
                    name: 'VHS Appears at Work',
                    description: 'Strange VHS tape appears at the video store on day 3',
                    oneShot: true,
                    flagWhenComplete: 'vhsAppeared',
                    triggers: [
                        { type: 'day', comparison: '>=', day: 3 },
                        { type: 'flag', flagName: 'vhsAppeared', shouldBe: 'false' },
                        { type: 'map', mapId: 'Video_Store' }
                    ],
                    actions: [
                        { 
                            type: 'spawnItem', 
                            itemId: 'magic_vhs', 
                            mapId: 'Video_Store', 
                            x: 8, 
                            y: 5 
                        },
                        { 
                            type: 'showMessage', 
                            message: "Something's different about the store today...",
                            color: 'CYAN'
                        }
                    ]
                },
                
                // ===== EVENT: PICKED UP VHS =====
                'vhs_pickup': {
                    type: 'event',
                    name: 'Picked Up VHS',
                    description: 'Player picks up the mysterious VHS tape',
                    oneShot: true,
                    flagWhenComplete: 'pickedUpVHS',
                    triggers: [
                        { type: 'hasItem', itemId: 'magic_vhs' },
                        { type: 'flag', flagName: 'pickedUpVHS', shouldBe: 'false' }
                    ],
                    actions: [
                        { 
                            type: 'showMessage', 
                            message: 'The tape feels unnaturally cold in your hands.',
                            color: 'MAGENTA'
                        },
                        { 
                            type: 'showMessage', 
                            message: "You can't quite focus on the label...",
                            color: 'MAGENTA'
                        },
                        { 
                            type: 'showMessage', 
                            message: 'Maybe you should watch it when you get home.',
                            color: 'CYAN'
                        },
                        {
                            type: 'addJournal',
                            title: 'The Unmarked Tape',
                            content: "Found a strange VHS at work today. The label is covered in symbols I don't recognize. Eddie said someone returned it this morning. Who rents tapes like this? I should probably watch it when I get home. Make sure it's not damaged."
                        }
                    ]
                },
                
                // ===== EVENT: VHS TRANSPORT SEQUENCE =====
                'vhs_transport': {
                    type: 'event',
                    name: 'VHS Transport Sequence',
                    description: 'Watching the VHS at home triggers the transport to the goblin realm',
                    oneShot: true,
                    flagWhenComplete: 'transported',
                    triggers: [
                        { type: 'position', x: 6, y: 1, mapId: 'Overworld' }, // Bed tile in apartment
                        { type: 'hasItem', itemId: 'magic_vhs' },
                        { type: 'flag', flagName: 'transported', shouldBe: 'false' },
                        { type: 'flag', flagName: 'tryingToRestWithVHS', shouldBe: 'true' }
                    ],
                    actions: [
                        { 
                            type: 'customCode',
                            code: `fadeToBlack(() => {
    addMessage("===================");
    addMessage("You can't stop thinking about that tape...");
    addMessage("You put it in the VCR.");
    addMessage("===================");
    
    setTimeout(() => {
        addMessage("Static fills the screen.", CGA.CYAN);
        
        setTimeout(() => {
            addMessage("The static forms patterns...", CGA.MAGENTA);
            
            setTimeout(() => {
                addMessage("The patterns become symbols...", CGA.MAGENTA);
                
                setTimeout(() => {
                    addMessage("The symbols burn into your eyes...", CGA.MAGENTA);
                    
                    setTimeout(() => {
                        addMessage("===================");
                        addMessage("Everything goes white.");
                        addMessage("===================");
                        
                        setTimeout(() => {
                            // TRANSPORT TO GOBLIN REALM
                            loadMap('Dungeon1');
                            gs.player.x = 10;
                            gs.player.y = 7;
                            
                            // Remove VHS from inventory
                            const vhsIndex = gs.player.inventory.indexOf('magic_vhs');
                            if (vhsIndex > -1) {
                                gs.player.inventory.splice(vhsIndex, 1);
                            }
                            
                            gs.flags.inMansfield = false;
                            gs.flags.inGoblinRealm = true;
                            
                            setTimeout(() => {
                                clearFade();
                                addMessage("===================");
                                addMessage("You wake up on cold stone.");
                                addMessage("This isn't your bedroom.");
                                addMessage("This isn't Mansfield.");
                                addMessage("===================");
                                
                                addJournalEntry('What Just Happened?', [
                                    { type: 'text', content: "I watched the tape. I shouldn't have watched the tape." },
                                    { type: 'text', content: 'Now I\\'m... somewhere else. Stone walls. Cold air. The smell of damp earth.' },
                                    { type: 'text', content: 'Where am I? How do I get home?' }
                                ]);
                                
                                renderWorld();
                                updateExploration();
                                updateStatus();
                            }, 500);
                        }, 2000);
                    }, 1500);
                }, 1500);
            }, 1500);
        }, 1500);
    }, 1000);
});`
                        }
                    ]
                }
            }
        };
        
        let currentFilter = 'all';
        let selectedNodeId = null;
        
        // ===== NODE TEMPLATES =====
        const nodeTemplates = {
            dialogue: {
                type: 'dialogue',
                name: 'New NPC',
                sprite: 'villager',
                isShopkeeper: false,
                dialogueLines: [
                    {
                        id: 'default',
                        text: 'Hello, traveler.',
                        triggers: [],
                        actions: []
                    }
                ]
            },
            
            event: {
                type: 'event',
                name: 'New Event',
                description: '',
                triggers: [],
                actions: [],
                oneShot: true,
                flagWhenComplete: ''
            },
            
            quest: {
                type: 'quest',
                name: 'New Quest',
                description: '',
                stages: [
                    {
                        id: 'start',
                        description: 'Quest started',
                        triggers: [],
                        actions: []
                    }
                ],
                rewards: {
                    gold: 0,
                    xp: 0,
                    items: []
                }
            }
        };
        
        // ===== CONDITION TYPES =====
        const conditionTypes = {
            flag: {
                name: 'Check Flag',
                fields: [
                    { name: 'flagName', type: 'text', label: 'Flag Name', placeholder: 'talkedBefore' },
                    { name: 'shouldBe', type: 'select', label: 'Should Be', options: ['true', 'false'] }
                ]
            },
            level: {
                name: 'Player Level',
                fields: [
                    { name: 'comparison', type: 'select', label: 'Comparison', options: ['>=', '>', '===', '<', '<='] },
                    { name: 'level', type: 'number', label: 'Level' }
                ]
            },
            day: {
                name: 'Day Number',
                fields: [
                    { name: 'comparison', type: 'select', label: 'Comparison', options: ['>=', '>', '===', '<'] },
                    { name: 'day', type: 'number', label: 'Day' }
                ]
            },
            map: {
                name: 'Current Map',
                fields: [
                    { name: 'mapId', type: 'text', label: 'Map ID', placeholder: 'Overworld' }
                ]
            },
            position: {
                name: 'Player Position',
                fields: [
                    { name: 'x', type: 'number', label: 'X' },
                    { name: 'y', type: 'number', label: 'Y' },
                    { name: 'mapId', type: 'text', label: 'Map (optional)' }
                ]
            },
            hasItem: {
                name: 'Has Item',
                fields: [
                    { name: 'itemId', type: 'text', label: 'Item ID', placeholder: 'silver_key' }
                ]
            },
            gold: {
                name: 'Has Gold',
                fields: [
                    { name: 'comparison', type: 'select', label: 'Comparison', options: ['>=', '>', '==='] },
                    { name: 'amount', type: 'number', label: 'Gold Amount' }
                ]
            }
        };
        
        // ===== ACTION TYPES =====
        const actionTypes = {
            showMessage: {
                name: 'Show Message',
                fields: [
                    { name: 'message', type: 'text', label: 'Message', placeholder: 'Something happened...' },
                    { name: 'color', type: 'select', label: 'Color', options: ['WHITE', 'CYAN', 'MAGENTA', 'YELLOW'] }
                ]
            },
            setFlag: {
                name: 'Set Flag',
                fields: [
                    { name: 'flagName', type: 'text', label: 'Flag Name', placeholder: 'questStarted' },
                    { name: 'value', type: 'select', label: 'Value', options: ['true', 'false'] }
                ]
            },
            giveReward: {
                name: 'Give Reward',
                fields: [
                    { name: 'gold', type: 'number', label: 'Gold' },
                    { name: 'xp', type: 'number', label: 'XP' },
                    { name: 'itemId', type: 'text', label: 'Item ID (optional)' }
                ]
            },
            spawnItem: {
                name: 'Spawn Item at Location',
                fields: [
                    { name: 'itemId', type: 'text', label: 'Item ID', placeholder: 'magic_vhs' },
                    { name: 'mapId', type: 'text', label: 'Map ID', placeholder: 'Video_Store' },
                    { name: 'x', type: 'number', label: 'X Position' },
                    { name: 'y', type: 'number', label: 'Y Position' }
                ]
            },
            transport: {
                name: 'Transport Player',
                fields: [
                    { name: 'mapId', type: 'text', label: 'To Map', placeholder: 'Dungeon1' },
                    { name: 'x', type: 'number', label: 'X Position' },
                    { name: 'y', type: 'number', label: 'Y Position' },
                    { name: 'fadeEffect', type: 'select', label: 'Fade Effect', options: ['none', 'black', 'white'] }
                ]
            },
            addJournal: {
                name: 'Add Journal Entry',
                fields: [
                    { name: 'title', type: 'text', label: 'Entry Title' },
                    { name: 'content', type: 'textarea', label: 'Content' }
                ]
            },
            customCode: {
                name: 'Custom JavaScript',
                fields: [
                    { name: 'code', type: 'textarea', label: 'JavaScript Code', placeholder: 'gameState.player.hp += 50;' }
                ]
            }
        };
        
        // ===== INITIALIZATION =====
        function init() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => switchTab(tab.dataset.tab));
            });
            renderNodeList();
        }
        
        function switchTab(tab) {
            currentFilter = tab;
            selectedNodeId = null;
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === tab);
            });
            renderNodeList();
            document.getElementById('editorArea').innerHTML = '<div class="empty-state">Select a node from the list or create a new one</div>';
        }
        
        function renderNodeList() {
            const list = document.getElementById('nodeList');
            list.innerHTML = '';
            
            const nodes = Object.entries(storyData.nodes)
                .filter(([id, node]) => currentFilter === 'all' || node.type === currentFilter)
                .sort(([a], [b]) => a.localeCompare(b));
            
            if (nodes.length === 0) {
                list.innerHTML = '<div class="empty-state">No nodes yet</div>';
                return;
            }
            
            nodes.forEach(([id, node]) => {
                const div = document.createElement('div');
                div.className = 'node-item' + (id === selectedNodeId ? ' selected' : '');
                
                const badgeClass = `badge-${node.type}`;
                const typeLabel = node.type.toUpperCase();
                
                div.innerHTML = `
                    <span class="node-type-badge ${badgeClass}">${typeLabel}</span>
                    <span>${node.name || id}</span>
                `;
                
                div.onclick = () => selectNode(id);
                list.appendChild(div);
            });
        }
        
        function selectNode(id) {
            selectedNodeId = id;
            renderNodeList();
            renderEditor();
        }
        
        function addNode(type) {
            const id = prompt(`Enter ${type} ID (e.g., 'eddie_video_clerk', 'vhs_appears'):`);
            if (!id) return;
            
            if (storyData.nodes[id]) {
                alert("Node with this ID already exists!");
                return;
            }
            
            storyData.nodes[id] = JSON.parse(JSON.stringify(nodeTemplates[type]));
            selectNode(id);
        }
        
        function deleteNode() {
            if (!selectedNodeId) {
                alert("No node selected!");
                return;
            }
            
            if (confirm(`Delete ${selectedNodeId}?`)) {
                delete storyData.nodes[selectedNodeId];
                selectedNodeId = null;
                renderNodeList();
                document.getElementById('editorArea').innerHTML = '<div class="empty-state">Node deleted. Select another or create new.</div>';
            }
        }
        
        // ===== EDITOR RENDERING =====
        function renderEditor() {
            const editor = document.getElementById('editorArea');
            const node = storyData.nodes[selectedNodeId];
            
            if (!node) return;
            
            let html = `<h2>${selectedNodeId} <span style="color: #888; font-size: 8px;">[${node.type.toUpperCase()}]</span></h2>`;
            
            if (node.type === 'dialogue') {
                html += renderDialogueEditor(node);
            } else if (node.type === 'event') {
                html += renderEventEditor(node);
            } else if (node.type === 'quest') {
                html += renderQuestEditor(node);
            }
            
            editor.innerHTML = html;
        }
        
        // ===== DIALOGUE EDITOR =====
        function renderDialogueEditor(node) {
            return `
                <label>NPC Name:</label>
                <input type="text" value="${node.name || ''}" onchange="updateNodeField('name', this.value)">
                
                <label>Sprite:</label>
                <select onchange="updateNodeField('sprite', this.value)">
                    <option value="villager" ${node.sprite === 'villager' ? 'selected' : ''}>Villager</option>
                    <option value="villager_old" ${node.sprite === 'villager_old' ? 'selected' : ''}>Old Villager</option>
                    <option value="villager_female" ${node.sprite === 'villager_female' ? 'selected' : ''}>Female Villager</option>
                    <option value="villager_worker" ${node.sprite === 'villager_worker' ? 'selected' : ''}>Worker</option>
                    <option value="merchant" ${node.sprite === 'merchant' ? 'selected' : ''}>Merchant</option>
                </select>
                
                <label>
                    <input type="checkbox" ${node.isShopkeeper ? 'checked' : ''} 
                           onchange="updateNodeField('isShopkeeper', this.checked)">
                    <span class="inline-label">Is Shopkeeper</span>
                </label>
                
                <div class="section">
                    <div class="section-title">DIALOGUE LINES</div>
                    <div class="help">
                        Lines are checked from bottom to top. Most specific conditions at bottom.<br>
                        Default/fallback line should be at top with no conditions.
                    </div>
                    ${renderDialogueLines(node.dialogueLines)}
                    <button class="button small-button" onclick="addDialogueLine()">+ Add Line</button>
                </div>
            `;
        }
        
        function renderDialogueLines(lines) {
            if (!lines || lines.length === 0) {
                return '<div style="color: #555; font-size: 7px;">No dialogue lines</div>';
            }
            
            return lines.map((line, idx) => `
                <div class="condition-block">
                    <div class="block-header">
                        <span class="block-number">Line ${idx + 1} (Priority: ${lines.length - idx})</span>
                        <div>
                            ${idx > 0 ? `<button class="button small-button" onclick="moveDialogueLine(${idx}, -1)">â†‘</button>` : ''}
                            ${idx < lines.length - 1 ? `<button class="button small-button" onclick="moveDialogueLine(${idx}, 1)">â†“</button>` : ''}
                            <button class="button danger small-button" onclick="deleteDialogueLine(${idx})">X</button>
                        </div>
                    </div>
                    
                    <label>Text:</label>
                    <textarea rows="2" onchange="updateDialogueLine(${idx}, 'text', this.value)">${line.text || ''}</textarea>
                    
                    <label>Triggers (when to show):</label>
                    <div id="line_triggers_${idx}">${renderTriggers(line.triggers, `line_${idx}`)}</div>
                    <button class="button small-button" onclick="addLineTrigger(${idx})">+ Trigger</button>
                    
                    <label>Actions (what happens when shown):</label>
                    <div id="line_actions_${idx}">${renderActions(line.actions, `line_${idx}`)}</div>
                    <button class="button small-button" onclick="addLineAction(${idx})">+ Action</button>
                </div>
            `).join('');
        }
        
        // ===== EVENT EDITOR =====
        function renderEventEditor(node) {
            return `
                <label>Event Name:</label>
                <input type="text" value="${node.name || ''}" onchange="updateNodeField('name', this.value)">
                
                <label>Description:</label>
                <textarea rows="2" onchange="updateNodeField('description', this.value)">${node.description || ''}</textarea>
                
                <label>
                    <input type="checkbox" ${node.oneShot ? 'checked' : ''} 
                           onchange="updateNodeField('oneShot', this.checked)">
                    <span class="inline-label">One Shot (only fires once)</span>
                </label>
                
                ${node.oneShot ? `
                    <label>Auto-Flag Name (prevents re-trigger):</label>
                    <input type="text" value="${node.flagWhenComplete || ''}" 
                           onchange="updateNodeField('flagWhenComplete', this.value)"
                           placeholder="${selectedNodeId}_completed">
                ` : ''}
                
                <div class="section">
                    <div class="section-title">TRIGGERS (When does this fire?)</div>
                    <div id="event_triggers">${renderTriggers(node.triggers, 'event')}</div>
                    <button class="button small-button" onclick="addEventTrigger()">+ Add Trigger</button>
                </div>
                
                <div class="section">
                    <div class="section-title">ACTIONS (What happens?)</div>
                    <div id="event_actions">${renderActions(node.actions, 'event')}</div>
                    <button class="button small-button" onclick="addEventAction()">+ Add Action</button>
                </div>
                
                <div class="flow-preview">
                    <div style="color: #0ff; font-size: 8px; margin-bottom: 5px;">FLOW PREVIEW:</div>
                    ${generateFlowPreview(node)}
                </div>
            `;
        }
        
        // ===== QUEST EDITOR =====
        function renderQuestEditor(node) {
            return `
                <label>Quest Name:</label>
                <input type="text" value="${node.name || ''}" onchange="updateNodeField('name', this.value)">
                
                <label>Description:</label>
                <textarea rows="2" onchange="updateNodeField('description', this.value)">${node.description || ''}</textarea>
                
                <div class="section">
                    <div class="section-title">QUEST STAGES</div>
                    ${renderQuestStages(node.stages)}
                    <button class="button small-button" onclick="addQuestStage()">+ Add Stage</button>
                </div>
                
                <div class="section">
                    <div class="section-title">REWARDS (on completion)</div>
                    <label>Gold:</label>
                    <input type="number" value="${node.rewards?.gold || 0}" 
                           onchange="updateQuestReward('gold', parseInt(this.value))">
                    <label>XP:</label>
                    <input type="number" value="${node.rewards?.xp || 0}" 
                           onchange="updateQuestReward('xp', parseInt(this.value))">
                    <label>Items (comma separated):</label>
                    <input type="text" value="${(node.rewards?.items || []).join(', ')}" 
                           onchange="updateQuestReward('items', this.value.split(',').map(s => s.trim()).filter(s => s))">
                </div>
            `;
        }
        
        function renderQuestStages(stages) {
            if (!stages || stages.length === 0) {
                return '<div style="color: #555; font-size: 7px;">No stages</div>';
            }
            
            return stages.map((stage, idx) => `
                <div class="condition-block">
                    <div class="block-header">
                        <span class="block-number">Stage ${idx + 1}: ${stage.id}</span>
                        <button class="button danger small-button" onclick="deleteQuestStage(${idx})">X</button>
                    </div>
                    
                    <label>Stage ID:</label>
                    <input type="text" value="${stage.id || ''}" onchange="updateQuestStage(${idx}, 'id', this.value)">
                    
                    <label>Description:</label>
                    <textarea rows="2" onchange="updateQuestStage(${idx}, 'description', this.value)">${stage.description || ''}</textarea>
                    
                    <label>Completion Triggers:</label>
                    <div id="stage_triggers_${idx}">${renderTriggers(stage.triggers, `stage_${idx}`)}</div>
                    <button class="button small-button" onclick="addStageTrigger(${idx})">+ Trigger</button>
                    
                    <label>Completion Actions:</label>
                    <div id="stage_actions_${idx}">${renderActions(stage.actions, `stage_${idx}`)}</div>
                    <button class="button small-button" onclick="addStageAction(${idx})">+ Action</button>
                </div>
            `).join('');
        }
        
        // ===== SHARED: TRIGGERS & ACTIONS =====
        function renderTriggers(triggers, context) {
            if (!triggers || triggers.length === 0) {
                return '<div style="color: #555; font-size: 7px;">No triggers (always active)</div>';
            }
            
            return triggers.map((trigger, idx) => `
                <div style="background: #002; border: 1px solid #040; padding: 8px; margin: 5px 0;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span style="color: #ff0; font-size: 7px;">Trigger ${idx + 1}</span>
                        <button class="button danger small-button" onclick="deleteTrigger('${context}', ${idx})">X</button>
                    </div>
                    
                    <label>Type:</label>
                    <select onchange="updateTriggerType('${context}', ${idx}, this.value)">
                        ${Object.entries(conditionTypes).map(([key, type]) => `
                            <option value="${key}" ${trigger.type === key ? 'selected' : ''}>${type.name}</option>
                        `).join('')}
                    </select>
                    
                    ${renderTriggerFields(trigger, context, idx)}
                </div>
            `).join('');
        }
        
        function renderTriggerFields(trigger, context, idx) {
            const type = conditionTypes[trigger.type];
            if (!type) return '';
            
            return type.fields.map(field => {
                const value = trigger[field.name] || '';
                
                if (field.type === 'select') {
                    return `
                        <label>${field.label}:</label>
                        <select onchange="updateTriggerField('${context}', ${idx}, '${field.name}', this.value)">
                            ${field.options.map(opt => `
                                <option value="${opt}" ${value == opt ? 'selected' : ''}>${opt}</option>
                            `).join('')}
                        </select>
                    `;
                } else if (field.type === 'number') {
                    return `
                        <label>${field.label}:</label>
                        <input type="number" value="${value}" 
                               onchange="updateTriggerField('${context}', ${idx}, '${field.name}', parseInt(this.value))"
                               placeholder="${field.placeholder || ''}">
                    `;
                } else {
                    return `
                        <label>${field.label}:</label>
                        <input type="text" value="${value}" 
                               onchange="updateTriggerField('${context}', ${idx}, '${field.name}', this.value)"
                               placeholder="${field.placeholder || ''}">
                    `;
                }
            }).join('');
        }
        
        function renderActions(actions, context) {
            if (!actions || actions.length === 0) {
                return '<div style="color: #555; font-size: 7px;">No actions</div>';
            }
            
            return actions.map((action, idx) => `
                <div style="background: #002; border: 1px solid #040; padding: 8px; margin: 5px 0;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span style="color: #0f0; font-size: 7px;">Action ${idx + 1}: ${actionTypes[action.type]?.name || action.type}</span>
                        <button class="button danger small-button" onclick="deleteAction('${context}', ${idx})">X</button>
                    </div>
                    
                    <label>Type:</label>
                    <select onchange="updateActionType('${context}', ${idx}, this.value)">
                        ${Object.entries(actionTypes).map(([key, type]) => `
                            <option value="${key}" ${action.type === key ? 'selected' : ''}>${type.name}</option>
                        `).join('')}
                    </select>
                    
                    ${renderActionFields(action, context, idx)}
                </div>
            `).join('');
        }
        
        function renderActionFields(action, context, idx) {
            const type = actionTypes[action.type];
            if (!type) return '';
            
            return type.fields.map(field => {
                const value = action[field.name] || '';
                
                if (field.type === 'select') {
                    return `
                        <label>${field.label}:</label>
                        <select onchange="updateActionField('${context}', ${idx}, '${field.name}', this.value)">
                            ${field.options.map(opt => `
                                <option value="${opt}" ${value == opt ? 'selected' : ''}>${opt}</option>
                            `).join('')}
                        </select>
                    `;
                } else if (field.type === 'textarea') {
                    return `
                        <label>${field.label}:</label>
                        <textarea rows="3" onchange="updateActionField('${context}', ${idx}, '${field.name}', this.value)"
                                  placeholder="${field.placeholder || ''}">${value}</textarea>
                    `;
                } else if (field.type === 'number') {
                    return `
                        <label>${field.label}:</label>
                        <input type="number" value="${value}" 
                               onchange="updateActionField('${context}', ${idx}, '${field.name}', parseInt(this.value))"
                               placeholder="${field.placeholder || ''}">
                    `;
                } else {
                    return `
                        <label>${field.label}:</label>
                        <input type="text" value="${value}" 
                               onchange="updateActionField('${context}', ${idx}, '${field.name}', this.value)"
                               placeholder="${field.placeholder || ''}">
                    `;
                }
            }).join('');
        }
        
        // ===== FLOW PREVIEW =====
        function generateFlowPreview(node) {
            let preview = '';
            
            if (node.triggers && node.triggers.length > 0) {
                preview += '<div class="flow-node"><div class="flow-condition">IF: ';
                preview += node.triggers.map(t => {
                    if (t.type === 'flag') return `flag.${t.flagName} = ${t.shouldBe}`;
                    if (t.type === 'map') return `currentMap = ${t.mapId}`;
                    if (t.type === 'day') return `day ${t.comparison} ${t.day}`;
                    if (t.type === 'level') return `level ${t.comparison} ${t.level}`;
                    if (t.type === 'position') return `pos = (${t.x}, ${t.y})`;
                    if (t.type === 'hasItem') return `has ${t.itemId}`;
                    return t.type;
                }).join(' AND ');
                preview += '</div></div>';
            }
            
            if (node.actions && node.actions.length > 0) {
                node.actions.forEach(action => {
                    preview += '<div class="flow-node"><div class="flow-action">THEN: ';
                    if (action.type === 'showMessage') preview += `Show "${action.message}"`;
                    else if (action.type === 'setFlag') preview += `Set flag.${action.flagName} = ${action.value}`;
                    else if (action.type === 'giveReward') preview += `Give ${action.gold}g, ${action.xp}xp`;
                    else if (action.type === 'spawnItem') preview += `Spawn ${action.itemId} at ${action.mapId}`;
                    else if (action.type === 'transport') preview += `Transport to ${action.mapId}`;
                    else if (action.type === 'addJournal') preview += `Journal: "${action.title}"`;
                    else if (action.type === 'customCode') preview += `Custom code (see above)`;
                    else preview += action.type;
                    preview += '</div></div>';
                });
            }
            
            if (node.oneShot) {
                const flagName = node.flagWhenComplete || `${selectedNodeId}_completed`;
                preview += `<div class="flow-node"><div class="flow-action">FINALLY: Set flag.${flagName} = true (prevent re-trigger)</div></div>`;
            }
            
            return preview || '<div style="color: #555;">No flow to preview</div>';
        }
        
        // ===== UPDATE FUNCTIONS =====
        function updateNodeField(field, value) {
            const node = storyData.nodes[selectedNodeId];
            node[field] = value;
        }
        
        // Dialogue line updates
        function addDialogueLine() {
            const node = storyData.nodes[selectedNodeId];
            if (!node.dialogueLines) node.dialogueLines = [];
            node.dialogueLines.push({
                id: `line_${node.dialogueLines.length}`,
                text: 'New dialogue...',
                triggers: [],
                actions: []
            });
            renderEditor();
        }
        
        function deleteDialogueLine(idx) {
            const node = storyData.nodes[selectedNodeId];
            node.dialogueLines.splice(idx, 1);
            renderEditor();
        }
        
        function moveDialogueLine(idx, direction) {
            const node = storyData.nodes[selectedNodeId];
            const newIdx = idx + direction;
            [node.dialogueLines[idx], node.dialogueLines[newIdx]] = 
                [node.dialogueLines[newIdx], node.dialogueLines[idx]];
            renderEditor();
        }
        
        function updateDialogueLine(idx, field, value) {
            const node = storyData.nodes[selectedNodeId];
            node.dialogueLines[idx][field] = value;
        }
        
        function addLineTrigger(lineIdx) {
            const node = storyData.nodes[selectedNodeId];
            if (!node.dialogueLines[lineIdx].triggers) node.dialogueLines[lineIdx].triggers = [];
            node.dialogueLines[lineIdx].triggers.push({ type: 'flag', flagName: '', shouldBe: 'true' });
            renderEditor();
        }
        
        function addLineAction(lineIdx) {
            const node = storyData.nodes[selectedNodeId];
            if (!node.dialogueLines[lineIdx].actions) node.dialogueLines[lineIdx].actions = [];
            node.dialogueLines[lineIdx].actions.push({ type: 'showMessage', message: '' });
            renderEditor();
        }
        
        // Event updates
        function addEventTrigger() {
            const node = storyData.nodes[selectedNodeId];
            if (!node.triggers) node.triggers = [];
            node.triggers.push({ type: 'flag', flagName: '', shouldBe: 'true' });
            renderEditor();
        }
        
        function addEventAction() {
            const node = storyData.nodes[selectedNodeId];
            if (!node.actions) node.actions = [];
            node.actions.push({ type: 'showMessage', message: '' });
            renderEditor();
        }
        
        // Quest updates
        function addQuestStage() {
            const node = storyData.nodes[selectedNodeId];
            if (!node.stages) node.stages = [];
            const stageNum = node.stages.length + 1;
            node.stages.push({
                id: `stage_${stageNum}`,
                description: `Stage ${stageNum}`,
                triggers: [],
                actions: []
            });
            renderEditor();
        }
        
        function deleteQuestStage(idx) {
            const node = storyData.nodes[selectedNodeId];
            node.stages.splice(idx, 1);
            renderEditor();
        }
        
        function updateQuestStage(idx, field, value) {
            const node = storyData.nodes[selectedNodeId];
            node.stages[idx][field] = value;
        }
        
        function updateQuestReward(field, value) {
            const node = storyData.nodes[selectedNodeId];
            if (!node.rewards) node.rewards = {};
            node.rewards[field] = value;
        }
        
        function addStageTrigger(stageIdx) {
            const node = storyData.nodes[selectedNodeId];
            if (!node.stages[stageIdx].triggers) node.stages[stageIdx].triggers = [];
            node.stages[stageIdx].triggers.push({ type: 'flag', flagName: '', shouldBe: 'true' });
            renderEditor();
        }
        
        function addStageAction(stageIdx) {
            const node = storyData.nodes[selectedNodeId];
            if (!node.stages[stageIdx].actions) node.stages[stageIdx].actions = [];
            node.stages[stageIdx].actions.push({ type: 'showMessage', message: '' });
            renderEditor();
        }
        
        // Generic trigger/action updates
        function getTriggerArray(context) {
            const node = storyData.nodes[selectedNodeId];
            if (context.startsWith('line_')) {
                const lineIdx = parseInt(context.split('_')[1]);
                return node.dialogueLines[lineIdx].triggers;
            } else if (context.startsWith('stage_')) {
                const stageIdx = parseInt(context.split('_')[1]);
                return node.stages[stageIdx].triggers;
            } else {
                return node.triggers;
            }
        }
        
        function getActionArray(context) {
            const node = storyData.nodes[selectedNodeId];
            if (context.startsWith('line_')) {
                const lineIdx = parseInt(context.split('_')[1]);
                return node.dialogueLines[lineIdx].actions;
            } else if (context.startsWith('stage_')) {
                const stageIdx = parseInt(context.split('_')[1]);
                return node.stages[stageIdx].actions;
            } else {
                return node.actions;
            }
        }
        
        function updateTriggerType(context, idx, type) {
            const triggers = getTriggerArray(context);
            triggers[idx] = { type: type };
            renderEditor();
        }
        
        function updateTriggerField(context, idx, field, value) {
            const triggers = getTriggerArray(context);
            triggers[idx][field] = value;
        }
        
        function deleteTrigger(context, idx) {
            const triggers = getTriggerArray(context);
            triggers.splice(idx, 1);
            renderEditor();
        }
        
        function updateActionType(context, idx, type) {
            const actions = getActionArray(context);
            actions[idx] = { type: type };
            renderEditor();
        }
        
        function updateActionField(context, idx, field, value) {
            const actions = getActionArray(context);
            actions[idx][field] = value;
        }
        
        function deleteAction(context, idx) {
            const actions = getActionArray(context);
            actions.splice(idx, 1);
            renderEditor();
        }
        
        // ===== CODE GENERATION =====
        function downloadAll() {
            const dialogueJS = generateDialogueJS();
            const eventsJS = generateEventsJS();
            
            downloadFile('dialogue.js', dialogueJS);
            downloadFile('events.js', eventsJS);
            
            alert("âœ… DOWNLOADED 2 FILES!\n\n1. dialogue.js\n2. events.js\n\nReplace your old files and refresh the game!");
        }
        
        function generateDialogueJS() {
            const dialogueNodes = Object.entries(storyData.nodes)
                .filter(([id, node]) => node.type === 'dialogue');
            
            const database = {};
            dialogueNodes.forEach(([id, node]) => {
                database[id] = {
                    name: node.name,
                    sprite: node.sprite,
                    isShopkeeper: node.isShopkeeper,
                    lines: node.dialogueLines.map(line => ({
                        text: line.text,
                        requires: convertTriggersToRequires(line.triggers),
                        sets: convertActionsToSets(line.actions)
                    }))
                };
            });
            
            return `// dialogue.js - Generated by Story Editor
console.log('=== DIALOGUE.JS IS LOADING ===');

const dialogueDatabase = ${JSON.stringify(database, null, 2)};

function getDialogue(npcId, gameState) {
    const npc = dialogueDatabase[npcId];
    if (!npc) {
        console.error('NPC "' + npcId + '" not found');
        return { text: "...", sets: null };
    }
    
    if (!gameState.flags) gameState.flags = {};
    
    for (let i = npc.lines.length - 1; i >= 0; i--) {
        const line = npc.lines[i];
        if (meetsRequirements(line.requires, gameState)) {
            return processDialogue(line, gameState, npcId);
        }
    }
    
    return processDialogue(npc.lines[0], gameState, npcId);
}

function meetsRequirements(requires, gameState) {
    if (!requires) return true;
    
    if (requires.level !== undefined && gameState.player.level < requires.level) return false;
    if (requires.gold !== undefined && gameState.player.gold < requires.gold) return false;
    if (requires.hasItem && !gameState.player.inventory.includes(requires.hasItem)) return false;
    
    if (requires.flags) {
        for (const [flag, requiredValue] of Object.entries(requires.flags)) {
            const currentValue = gameState.flags?.[flag];
            if (typeof requiredValue === 'boolean') {
                if (Boolean(currentValue) !== requiredValue) return false;
            } else if (currentValue !== requiredValue) {
                return false;
            }
        }
    }
    
    return true;
}

function processDialogue(line, gameState, npcId) {
    if (line.sets) {
        if (!gameState.flags) gameState.flags = {};
        Object.assign(gameState.flags, line.sets);
    }
    
    return {
        text: line.text,
        sets: line.sets || null,
        npcName: dialogueDatabase[npcId]?.name || "Unknown"
    };
}

function getNPCData(npcId) {
    return dialogueDatabase[npcId] || null;
}

console.log('=== DIALOGUE.JS LOADED ===');
console.log('Loaded ' + Object.keys(dialogueDatabase).length + ' NPCs');`;
        }
        
        function generateEventsJS() {
            const eventNodes = Object.entries(storyData.nodes)
                .filter(([id, node]) => node.type === 'event');
            
            const handlers = eventNodes.map(([id, node]) => {
                const flagName = node.flagWhenComplete || `${id}_completed`;
                
                return `    '${id}': {
        // ${node.description || 'No description'}
        canTrigger: (gs) => {
            ${node.oneShot ? `if (gs.flags.${flagName}) return false;` : ''}
            return ${generateTriggerCode(node.triggers)};
        },
        
        onTrigger: (gs) => {
            console.log('EVENT: ${id}');
            ${generateActionCode(node.actions)}
            ${node.oneShot ? `gs.flags.${flagName} = true;` : ''}
        }
    }`;
            }).join(',\n\n');
            
            return `// events.js - Generated by Story Editor
console.log('=== EVENTS.JS IS LOADING ===');

const eventHandlers = {
${handlers}
};

function checkEvents(gameState) {
    Object.entries(eventHandlers).forEach(([eventId, handler]) => {
        try {
            if (handler.canTrigger(gameState)) {
                console.log(\`Triggering event: \${eventId}\`);
                handler.onTrigger(gameState);
            }
        } catch (error) {
            console.error(\`Error in event \${eventId}:\`, error);
        }
    });
}

// ===== REST HOOK SYSTEM =====
const restHooks = {
    beforeRest: [
        // VHS watching hook
        function checkVHSWatching(gameState, location) {
            const currentTile = gameState.world.tiles[gameState.player.y]?.[gameState.player.x];
            
            if (currentTile === 'B' && gameState.player.inventory.includes('magic_vhs')) {
                gameState.flags.tryingToRestWithVHS = true;
                checkEvents(gameState);
                
                if (gameState.flags.transported) {
                    gameState.flags.tryingToRestWithVHS = false;
                    return true; // Cancel rest
                }
                
                gameState.flags.tryingToRestWithVHS = false;
            }
            
            return false;
        }
    ],
    
    afterRest: [
        // Day counter advancement
        function advanceDay(gameState, location) {
            if (location === 'bed') {
                gameState.dayCounter = (gameState.dayCounter || 0) + 1;
                console.log(\`Day advanced to: \${gameState.dayCounter}\`);
                
                // Reset daily flags
                gameState.dailyFlags = {
                    talkedToEddie: false,
                    visitedCoffeeShop: false,
                    wentToBar: false
                };
                
                // Show day number
                addMessage(\`Day \${gameState.dayCounter}\`, CGA.CYAN);
                
                // Check for events that trigger on new day
                checkEvents(gameState);
            }
        }
    ]
};

function runBeforeRestHooks(gameState, location) {
    for (const hook of restHooks.beforeRest) {
        try {
            const shouldCancel = hook(gameState, location);
            if (shouldCancel) {
                console.log('Rest cancelled by hook');
                return true;
            }
        } catch (error) {
            console.error('Error in beforeRest hook:', error);
        }
    }
    return false;
}

function runAfterRestHooks(gameState, location) {
    restHooks.afterRest.forEach(hook => {
        try {
            hook(gameState, location);
        } catch (error) {
            console.error('Error in afterRest hook:', error);
        }
    });
}

console.log('=== EVENTS.JS LOADED ===');
console.log(\`Registered \${Object.keys(eventHandlers).length} event handlers\`);
console.log(\`Registered \${restHooks.beforeRest.length} beforeRest hooks\`);
console.log(\`Registered \${restHooks.afterRest.length} afterRest hooks\`);`;
        }
        
        function convertTriggersToRequires(triggers) {
            if (!triggers || triggers.length === 0) return {};
            
            const requires = {};
            const flags = {};
            
            triggers.forEach(t => {
                if (t.type === 'flag') {
                    flags[t.flagName] = t.shouldBe === 'true' || t.shouldBe === true;
                } else if (t.type === 'level') {
                    requires.level = t.level;
                } else if (t.type === 'hasItem') {
                    requires.hasItem = t.itemId;
                } else if (t.type === 'gold') {
                    requires.gold = t.amount;
                }
            });
            
            if (Object.keys(flags).length > 0) requires.flags = flags;
            return requires;
        }
        
        function convertActionsToSets(actions) {
            if (!actions || actions.length === 0) return {};
            
            const sets = {};
            actions.forEach(a => {
                if (a.type === 'setFlag') {
                    sets[a.flagName] = a.value === 'true' || a.value === true;
                }
            });
            
            return sets;
        }
        
        function generateTriggerCode(triggers) {
            if (!triggers || triggers.length === 0) return 'true';
            
            const conditions = triggers.map(t => {
                if (t.type === 'flag') {
                    return `gs.flags.${t.flagName} === ${t.shouldBe}`;
                } else if (t.type === 'map') {
                    return `gs.currentMap === '${t.mapId}'`;
                } else if (t.type === 'day') {
                    return `gs.dayCounter ${t.comparison} ${t.day}`;
                } else if (t.type === 'level') {
                    return `gs.player.level ${t.comparison} ${t.level}`;
                } else if (t.type === 'position') {
                    let code = `gs.player.x === ${t.x} && gs.player.y === ${t.y}`;
                    if (t.mapId) code += ` && gs.currentMap === '${t.mapId}'`;
                    return code;
                } else if (t.type === 'hasItem') {
                    return `gs.player.inventory.includes('${t.itemId}')`;
                } else if (t.type === 'gold') {
                    return `gs.player.gold ${t.comparison} ${t.amount}`;
                }
                return 'true';
            });
            
            return conditions.join(' &&\n                   ');
        }
        
        function generateActionCode(actions) {
            if (!actions || actions.length === 0) return '// No actions';
            
            return actions.map(a => {
                if (a.type === 'showMessage') {
                    const color = a.color ? `, CGA.${a.color}` : '';
                    return `addMessage("${a.message}"${color});`;
                } else if (a.type === 'setFlag') {
                    return `gs.flags.${a.flagName} = ${a.value};`;
                } else if (a.type === 'giveReward') {
                    let code = '';
                    if (a.gold > 0) code += `gs.player.gold += ${a.gold}; addMessage("+${a.gold} gold!", CGA.CYAN);`;
                    if (a.xp > 0) code += ` gs.player.xp += ${a.xp}; checkLevelUp();`;
                    if (a.itemId) code += ` gs.player.inventory.push('${a.itemId}');`;
                    return code;
                } else if (a.type === 'spawnItem') {
                    return `
            const location = '${a.x},${a.y}';
            if (!treasureContents['${a.mapId}']) treasureContents['${a.mapId}'] = {};
            treasureContents['${a.mapId}'][location] = { gold: 0, items: ['${a.itemId}'] };
            const [x, y] = location.split(',').map(Number);
            const row = gs.world.tiles[y];
            gs.world.tiles[y] = row.substring(0, x) + '$' + row.substring(x + 1);
            renderWorld();`;
                } else if (a.type === 'transport') {
                    let code = '';
                    if (a.fadeEffect !== 'none') {
                        code += `fadeTo${a.fadeEffect === 'white' ? 'White' : 'Black'}(() => {`;
                    }
                    code += `
                loadMap('${a.mapId}');
                gs.player.x = ${a.x};
                gs.player.y = ${a.y};
                renderWorld();
                updateExploration();
                updateStatus();`;
                    if (a.fadeEffect !== 'none') {
                        code += `
                setTimeout(() => clearFade(), 150);
            });`;
                    }
                    return code;
                } else if (a.type === 'addJournal') {
                    return `addJournalEntry('${a.title}', [{ type: 'text', content: '${a.content.replace(/'/g, "\\'")}' }]);`;
                } else if (a.type === 'customCode') {
                    return a.code || '// Empty custom code';
                }
                return '// Unknown action';
            }).join('\n            ');
        }
        
        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/javascript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // ===== IMPORT/EXPORT =====
        function exportJSON() {
            const json = JSON.stringify(storyData, null, 2);
            document.getElementById('exportArea').value = json;
            
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'story_data.json';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function importJSON() {
            const json = document.getElementById('exportArea').value;
            if (!json.trim()) {
                alert("Paste JSON into the text area first!");
                return;
            }
            
            try {
                storyData = JSON.parse(json);
                selectedNodeId = null;
                renderNodeList();
                document.getElementById('editorArea').innerHTML = '<div class="empty-state">Data imported! Select a node to edit.</div>';
                alert("Story data imported successfully!");
            } catch (e) {
                alert("Invalid JSON: " + e.message);
            }
        }
        
        // Initialize
        init();
    </script>
</body>
</html>