<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goblinheart Unified Content Editor</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Press Start 2P', monospace;
            background-color: #000;
            color: #0f0;
            font-size: 10px;
            line-height: 1.6;
        }
        
        h1 {
            text-align: center;
            color: #0ff;
            font-size: 16px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #055;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }
        
        .panel {
            background-color: #001;
            border: 2px solid #0f0;
            padding: 15px;
        }
        
        .panel h2 {
            font-size: 11px;
            color: #0ff;
            margin: 0 0 15px 0;
            border-bottom: 1px solid #0f0;
            padding-bottom: 8px;
        }
        
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .tab {
            flex: 1;
            padding: 8px;
            background-color: #002;
            border: 2px solid #050;
            cursor: pointer;
            font-size: 7px;
            text-align: center;
            color: #0a0;
        }
        
        .tab:hover {
            background-color: #003;
            border-color: #0a0;
        }
        
        .tab.active {
            background-color: #004;
            border-color: #0ff;
            color: #0ff;
        }
        
        .node-list {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .node-item {
            padding: 8px;
            margin: 5px 0;
            background-color: #002;
            border: 1px solid #050;
            cursor: pointer;
            font-size: 8px;
        }
        
        .node-item:hover {
            background-color: #003;
            border-color: #0a0;
        }
        
        .node-item.selected {
            background-color: #004;
            border: 2px solid #0ff;
        }
        
        .node-type-badge {
            display: inline-block;
            padding: 2px 6px;
            font-size: 6px;
            border-radius: 3px;
            margin-right: 5px;
        }
        
        .badge-npc { background: #004; color: #0ff; border: 1px solid #0ff; }
        .badge-event { background: #400; color: #ff0; border: 1px solid #ff0; }
        
        .button {
            background-color: #003;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 8px 15px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
        }
        
        .button:hover {
            background-color: #005;
            border-color: #0ff;
        }
        
        .button.danger {
            border-color: #f00;
            color: #f00;
        }
        
        .button.danger:hover {
            background-color: #300;
        }
        
        .button.primary {
            background-color: #030;
            border-color: #0ff;
            color: #0ff;
        }
        
        input, textarea, select {
            width: 100%;
            background-color: #001;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            margin: 5px 0;
        }
        
        input[type="number"] {
            width: 100px;
        }
        
        input[type="checkbox"] {
            width: auto;
        }
        
        label {
            display: block;
            color: #ff0;
            font-size: 8px;
            margin: 10px 0 5px 0;
        }
        
        .inline-label {
            display: inline;
            margin-left: 5px;
        }
        
        .section {
            margin: 15px 0;
            padding: 12px;
            background-color: #002;
            border: 1px solid #0a0;
        }
        
        .section-title {
            color: #0ff;
            font-size: 9px;
            margin-bottom: 10px;
            border-bottom: 1px solid #050;
            padding-bottom: 5px;
        }
        
        .response-block {
            background-color: #001;
            border: 1px solid #050;
            padding: 10px;
            margin: 8px 0;
            position: relative;
        }
        
        .block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #030;
        }
        
        .block-number {
            color: #ff0;
            font-size: 8px;
        }
        
        .small-button {
            padding: 4px 8px;
            font-size: 7px;
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .export-area {
            margin-top: 20px;
        }
        
        textarea.export {
            min-height: 200px;
            font-family: 'Courier New', monospace;
            font-size: 9px;
        }
        
        .help {
            background-color: #002;
            border: 1px solid #050;
            padding: 10px;
            margin: 15px 0;
            font-size: 7px;
            color: #888;
            line-height: 1.8;
        }
        
        .empty-state {
            text-align: center;
            color: #555;
            padding: 40px;
            font-size: 9px;
        }
        
        .flow-preview {
            background-color: #002;
            border: 2px solid #0a0;
            padding: 15px;
            margin: 15px 0;
            font-size: 7px;
            color: #888;
        }
        
        .flow-node {
            background-color: #001;
            border: 1px solid #050;
            padding: 8px;
            margin: 5px 0;
            margin-left: 20px;
            border-left: 2px solid #0ff;
        }
        
        .flow-condition {
            color: #ff0;
            font-size: 6px;
        }
        
        .flow-action {
            color: #0f0;
            font-size: 6px;
        }
        
        .flow-text {
            color: #0ff;
            font-size: 6px;
        }
    </style>
</head>
<body>
    <h1>GOBLINHEART UNIFIED CONTENT EDITOR</h1>
    
    <div class="help" style="max-width: 1600px; margin: 0 auto 20px auto;">
        <strong style="color: #0ff;">ðŸŽ® UNIFIED EDITOR</strong><br>
        Create NPCs and Events in one place! NPCs are just events that can talk.<br>
        <strong style="color: #ff0;">Key Features:</strong><br>
        â€¢ NPCs have multiple "responses" (dialogue + actions based on conditions)<br>
        â€¢ Events can show messages, trigger effects, and change the world<br>
        â€¢ Both use the same trigger/action system<br>
        â€¢ Export directly to dialogue.js and events.js
    </div>
    
    <div class="container">
        <!-- Left Panel: Content List -->
        <div class="panel">
            <h2>CONTENT NODES</h2>
            
            <div class="tabs">
                <div class="tab active" data-tab="all">ALL</div>
                <div class="tab" data-tab="npc">NPCS</div>
                <div class="tab" data-tab="event">EVENTS</div>
            </div>
            
            <div class="button-row">
                <button class="button small-button" onclick="addNode('npc')">+ NPC</button>
                <button class="button small-button" onclick="addNode('event')">+ EVENT</button>
            </div>
            
            <button class="button danger small-button" onclick="deleteNode()" style="width: 100%;">DELETE NODE</button>
            
            <div class="node-list" id="nodeList"></div>
            
            <div class="export-area">
                <h2>EXPORT</h2>
                <button class="button primary" onclick="downloadAll()">ðŸ’¾ DOWNLOAD ALL</button>
                <button class="button" onclick="exportJSON()">EXPORT JSON</button>
                <button class="button" onclick="importJSON()">IMPORT JSON</button>
                <textarea class="export" id="exportArea" placeholder="JSON will appear here..."></textarea>
            </div>
        </div>
        
        <!-- Right Panel: Node Editor -->
        <div class="panel">
            <div id="editorArea">
                <div class="empty-state">
                    ðŸ‘ˆ Create or select a content node to begin editing
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== UNIFIED DATA STRUCTURE =====
        let contentData = {
            nodes: {
                // Example NPC
                'eddie_video_clerk': {
                    type: 'npc',
                    name: 'Eddie',
                    sprite: 'villager_worker',
                    isShopkeeper: false,
                    responses: [
                        {
                            id: 'default',
                            text: 'Hey! Ready for another shift?',
                            conditions: [],
                            actions: []
                        },
                        {
                            id: 'vhs_comment',
                            text: "Someone returned that tape this morning. Never seen one like it. Weird symbols and all. Check if it's damaged, will ya?",
                            conditions: [
                                { type: 'flag', flagName: 'vhsAppeared', shouldBe: 'true' },
                                { type: 'flag', flagName: 'eddieCommentedOnVHS', shouldBe: 'false' }
                            ],
                            actions: [
                                { type: 'setFlag', flagName: 'eddieCommentedOnVHS', value: 'true' }
                            ]
                        }
                    ]
                },
                
                // Example Event
                'vhs_appears': {
                    type: 'event',
                    name: 'VHS Appears at Work',
                    description: 'Strange VHS tape appears at the video store on day 3',
                    oneShot: true,
                    conditions: [
                        { type: 'day', comparison: '>=', day: 3 },
                        { type: 'flag', flagName: 'vhsAppeared', shouldBe: 'false' },
                        { type: 'map', mapId: 'Video_Store' }
                    ],
                    actions: [
                        { 
                            type: 'spawnItem', 
                            itemId: 'magic_vhs', 
                            mapId: 'Video_Store', 
                            x: 8, 
                            y: 5 
                        },
                        { 
                            type: 'showMessage', 
                            message: "Something's different about the store today...",
                            color: 'CYAN'
                        }
                    ]
                }
            }
        };
        
        let currentFilter = 'all';
        let selectedNodeId = null;
        
        // ===== NODE TEMPLATES =====
        const nodeTemplates = {
            npc: {
                type: 'npc',
                name: 'New NPC',
                sprite: 'villager',
                isShopkeeper: false,
                responses: [
                    {
                        id: 'default',
                        text: 'Hello, traveler.',
                        conditions: [],
                        actions: []
                    }
                ]
            },
            
            event: {
                type: 'event',
                name: 'New Event',
                description: '',
                oneShot: true,
                conditions: [],
                actions: []
            }
        };
        
        // ===== CONDITION TYPES =====
        const conditionTypes = {
            flag: {
                name: 'Check Flag',
                fields: [
                    { name: 'flagName', type: 'text', label: 'Flag Name', placeholder: 'talkedBefore' },
                    { name: 'shouldBe', type: 'select', label: 'Should Be', options: ['true', 'false'] }
                ]
            },
            level: {
                name: 'Player Level',
                fields: [
                    { name: 'comparison', type: 'select', label: 'Comparison', options: ['>=', '>', '===', '<', '<='] },
                    { name: 'level', type: 'number', label: 'Level' }
                ]
            },
            day: {
                name: 'Day Number',
                fields: [
                    { name: 'comparison', type: 'select', label: 'Comparison', options: ['>=', '>', '===', '<'] },
                    { name: 'day', type: 'number', label: 'Day' }
                ]
            },
            map: {
                name: 'Current Map',
                fields: [
                    { name: 'mapId', type: 'text', label: 'Map ID', placeholder: 'Overworld' }
                ]
            },
            position: {
                name: 'Player Position',
                fields: [
                    { name: 'x', type: 'number', label: 'X' },
                    { name: 'y', type: 'number', label: 'Y' },
                    { name: 'mapId', type: 'text', label: 'Map (optional)' }
                ]
            },
            hasItem: {
                name: 'Has Item',
                fields: [
                    { name: 'itemId', type: 'text', label: 'Item ID', placeholder: 'silver_key' }
                ]
            },
            gold: {
                name: 'Has Gold',
                fields: [
                    { name: 'comparison', type: 'select', label: 'Comparison', options: ['>=', '>', '==='] },
                    { name: 'amount', type: 'number', label: 'Gold Amount' }
                ]
            }
        };
        
        // ===== ACTION TYPES =====
        const actionTypes = {
            showMessage: {
                name: 'Show Message',
                fields: [
                    { name: 'message', type: 'text', label: 'Message', placeholder: 'Something happened...' },
                    { name: 'color', type: 'select', label: 'Color', options: ['WHITE', 'CYAN', 'MAGENTA', 'YELLOW'] }
                ]
            },
            setFlag: {
                name: 'Set Flag',
                fields: [
                    { name: 'flagName', type: 'text', label: 'Flag Name', placeholder: 'questStarted' },
                    { name: 'value', type: 'select', label: 'Value', options: ['true', 'false'] }
                ]
            },
            giveReward: {
                name: 'Give Reward',
                fields: [
                    { name: 'gold', type: 'number', label: 'Gold' },
                    { name: 'xp', type: 'number', label: 'XP' },
                    { name: 'itemId', type: 'text', label: 'Item ID (optional)' }
                ]
            },
            spawnItem: {
                name: 'Spawn Item at Location',
                fields: [
                    { name: 'itemId', type: 'text', label: 'Item ID', placeholder: 'magic_vhs' },
                    { name: 'mapId', type: 'text', label: 'Map ID', placeholder: 'Video_Store' },
                    { name: 'x', type: 'number', label: 'X Position' },
                    { name: 'y', type: 'number', label: 'Y Position' }
                ]
            },
            transport: {
                name: 'Transport Player',
                fields: [
                    { name: 'mapId', type: 'text', label: 'To Map', placeholder: 'Dungeon1' },
                    { name: 'x', type: 'number', label: 'X Position' },
                    { name: 'y', type: 'number', label: 'Y Position' },
                    { name: 'fadeEffect', type: 'select', label: 'Fade Effect', options: ['none', 'black', 'white'] }
                ]
            },
            addJournal: {
                name: 'Add Journal Entry',
                fields: [
                    { name: 'title', type: 'text', label: 'Entry Title' },
                    { name: 'content', type: 'textarea', label: 'Content' }
                ]
            },
            customCode: {
                name: 'Custom JavaScript',
                fields: [
                    { name: 'code', type: 'textarea', label: 'JavaScript Code', placeholder: 'gameState.player.hp += 50;' }
                ]
            }
        };
        
        // ===== INITIALIZATION =====
        function init() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => switchTab(tab.dataset.tab));
            });
            renderNodeList();
        }
        
        function switchTab(tab) {
            currentFilter = tab;
            selectedNodeId = null;
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === tab);
            });
            renderNodeList();
            document.getElementById('editorArea').innerHTML = '<div class="empty-state">Select a node from the list or create a new one</div>';
        }
        
        function renderNodeList() {
            const list = document.getElementById('nodeList');
            list.innerHTML = '';
            
            const nodes = Object.entries(contentData.nodes)
                .filter(([id, node]) => currentFilter === 'all' || node.type === currentFilter)
                .sort(([a], [b]) => a.localeCompare(b));
            
            if (nodes.length === 0) {
                list.innerHTML = '<div class="empty-state">No nodes yet</div>';
                return;
            }
            
            nodes.forEach(([id, node]) => {
                const div = document.createElement('div');
                div.className = 'node-item' + (id === selectedNodeId ? ' selected' : '');
                
                const badgeClass = `badge-${node.type}`;
                const typeLabel = node.type.toUpperCase();
                
                div.innerHTML = `
                    <span class="node-type-badge ${badgeClass}">${typeLabel}</span>
                    <span>${node.name || id}</span>
                `;
                
                div.onclick = () => selectNode(id);
                list.appendChild(div);
            });
        }
        
        function selectNode(id) {
            selectedNodeId = id;
            renderNodeList();
            renderEditor();
        }
        
        function addNode(type) {
            const id = prompt(`Enter ${type} ID (e.g., 'guard_captain', 'door_unlock_event'):`);
            if (!id) return;
            
            if (contentData.nodes[id]) {
                alert("Node with this ID already exists!");
                return;
            }
            
            contentData.nodes[id] = JSON.parse(JSON.stringify(nodeTemplates[type]));
            selectNode(id);
        }
        
        function deleteNode() {
            if (!selectedNodeId) {
                alert("No node selected!");
                return;
            }
            
            if (confirm(`Delete ${selectedNodeId}?`)) {
                delete contentData.nodes[selectedNodeId];
                selectedNodeId = null;
                renderNodeList();
                document.getElementById('editorArea').innerHTML = '<div class="empty-state">Node deleted. Select another or create new.</div>';
            }
        }
        
        // ===== EDITOR RENDERING =====
        function renderEditor() {
            const editor = document.getElementById('editorArea');
            const node = contentData.nodes[selectedNodeId];
            
            if (!node) return;
            
            let html = `<h2>${selectedNodeId} <span style="color: #888; font-size: 8px;">[${node.type.toUpperCase()}]</span></h2>`;
            
            if (node.type === 'npc') {
                html += renderNPCEditor(node);
            } else if (node.type === 'event') {
                html += renderEventEditor(node);
            }
            
            editor.innerHTML = html;
        }
        
        // ===== NPC EDITOR =====
        function renderNPCEditor(node) {
            return `
                <label>NPC Name:</label>
                <input type="text" value="${node.name || ''}" onchange="updateNodeField('name', this.value)">
                
                <label>Sprite:</label>
                <select onchange="updateNodeField('sprite', this.value)">
                    <option value="villager" ${node.sprite === 'villager' ? 'selected' : ''}>Villager</option>
                    <option value="villager_old" ${node.sprite === 'villager_old' ? 'selected' : ''}>Old Villager</option>
                    <option value="villager_female" ${node.sprite === 'villager_female' ? 'selected' : ''}>Female Villager</option>
                    <option value="villager_worker" ${node.sprite === 'villager_worker' ? 'selected' : ''}>Worker</option>
                    <option value="villager_innkeeper" ${node.sprite === 'villager_innkeeper' ? 'selected' : ''}>Innkeeper</option>
                    <option value="merchant" ${node.sprite === 'merchant' ? 'selected' : ''}>Merchant</option>
                </select>
                
                <label>
                    <input type="checkbox" ${node.isShopkeeper ? 'checked' : ''} 
                           onchange="updateNodeField('isShopkeeper', this.checked)">
                    <span class="inline-label">Is Shopkeeper</span>
                </label>
                
                <div class="section">
                    <div class="section-title">DIALOGUE RESPONSES</div>
                    <div class="help">
                        Responses are checked from bottom to top. Most specific at bottom.<br>
                        Default response (no conditions) should be at top.
                    </div>
                    ${renderResponses(node.responses)}
                    <button class="button small-button" onclick="addResponse()">+ Add Response</button>
                </div>
            `;
        }
        
        function renderResponses(responses) {
            if (!responses || responses.length === 0) {
                return '<div style="color: #555; font-size: 7px;">No responses</div>';
            }
            
            return responses.map((resp, idx) => `
                <div class="response-block">
                    <div class="block-header">
                        <span class="block-number">Response ${idx + 1} (Priority: ${responses.length - idx})</span>
                        <div>
                            ${idx > 0 ? `<button class="button small-button" onclick="moveResponse(${idx}, -1)">â†‘</button>` : ''}
                            ${idx < responses.length - 1 ? `<button class="button small-button" onclick="moveResponse(${idx}, 1)">â†“</button>` : ''}
                            <button class="button danger small-button" onclick="deleteResponse(${idx})">X</button>
                        </div>
                    </div>
                    
                    <label>Dialogue Text:</label>
                    <textarea rows="2" onchange="updateResponse(${idx}, 'text', this.value)">${resp.text || ''}</textarea>
                    
                    <label>Conditions (when to show this response):</label>
                    <div id="resp_conditions_${idx}">${renderConditions(resp.conditions, `resp_${idx}`)}</div>
                    <button class="button small-button" onclick="addCondition('resp_${idx}')">+ Condition</button>
                    
                    <label>Actions (what happens when said):</label>
                    <div id="resp_actions_${idx}">${renderActions(resp.actions, `resp_${idx}`)}</div>
                    <button class="button small-button" onclick="addAction('resp_${idx}')">+ Action</button>
                </div>
            `).join('');
        }
        
        // ===== EVENT EDITOR =====
        function renderEventEditor(node) {
            return `
                <label>Event Name:</label>
                <input type="text" value="${node.name || ''}" onchange="updateNodeField('name', this.value)">
                
                <label>Description:</label>
                <textarea rows="2" onchange="updateNodeField('description', this.value)">${node.description || ''}</textarea>
                
                <label>
                    <input type="checkbox" ${node.oneShot ? 'checked' : ''} 
                           onchange="updateNodeField('oneShot', this.checked)">
                    <span class="inline-label">One Shot (only fires once)</span>
                </label>
                
                <div class="section">
                    <div class="section-title">CONDITIONS (When does this fire?)</div>
                    <div id="event_conditions">${renderConditions(node.conditions, 'event')}</div>
                    <button class="button small-button" onclick="addCondition('event')">+ Add Condition</button>
                </div>
                
                <div class="section">
                    <div class="section-title">ACTIONS (What happens?)</div>
                    <div id="event_actions">${renderActions(node.actions, 'event')}</div>
                    <button class="button small-button" onclick="addAction('event')">+ Add Action</button>
                </div>
                
                <div class="flow-preview">
                    <div style="color: #0ff; font-size: 8px; margin-bottom: 5px;">FLOW PREVIEW:</div>
                    ${generateFlowPreview(node)}
                </div>
            `;
        }
        
        // ===== SHARED: CONDITIONS & ACTIONS =====
        function renderConditions(conditions, context) {
            if (!conditions || conditions.length === 0) {
                return '<div style="color: #555; font-size: 7px;">No conditions (always triggers)</div>';
            }
            
            return conditions.map((cond, idx) => `
                <div style="background: #002; border: 1px solid #040; padding: 8px; margin: 5px 0;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span style="color: #ff0; font-size: 7px;">Condition ${idx + 1}</span>
                        <button class="button danger small-button" onclick="deleteCondition('${context}', ${idx})">X</button>
                    </div>
                    
                    <label>Type:</label>
                    <select onchange="updateConditionType('${context}', ${idx}, this.value)">
                        ${Object.entries(conditionTypes).map(([key, type]) => `
                            <option value="${key}" ${cond.type === key ? 'selected' : ''}>${type.name}</option>
                        `).join('')}
                    </select>
                    
                    ${renderConditionFields(cond, context, idx)}
                </div>
            `).join('');
        }
        
        function renderConditionFields(cond, context, idx) {
            const type = conditionTypes[cond.type];
            if (!type) return '';
            
            return type.fields.map(field => {
                const value = cond[field.name] || '';
                
                if (field.type === 'select') {
                    return `
                        <label>${field.label}:</label>
                        <select onchange="updateConditionField('${context}', ${idx}, '${field.name}', this.value)">
                            ${field.options.map(opt => `
                                <option value="${opt}" ${value == opt ? 'selected' : ''}>${opt}</option>
                            `).join('')}
                        </select>
                    `;
                } else if (field.type === 'number') {
                    return `
                        <label>${field.label}:</label>
                        <input type="number" value="${value}" 
                               onchange="updateConditionField('${context}', ${idx}, '${field.name}', parseInt(this.value))"
                               placeholder="${field.placeholder || ''}">
                    `;
                } else {
                    return `
                        <label>${field.label}:</label>
                        <input type="text" value="${value}" 
                               onchange="updateConditionField('${context}', ${idx}, '${field.name}', this.value)"
                               placeholder="${field.placeholder || ''}">
                    `;
                }
            }).join('');
        }
        
        function renderActions(actions, context) {
            if (!actions || actions.length === 0) {
                return '<div style="color: #555; font-size: 7px;">No actions</div>';
            }
            
            return actions.map((action, idx) => `
                <div style="background: #002; border: 1px solid #040; padding: 8px; margin: 5px 0;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span style="color: #0f0; font-size: 7px;">Action ${idx + 1}: ${actionTypes[action.type]?.name || action.type}</span>
                        <button class="button danger small-button" onclick="deleteAction('${context}', ${idx})">X</button>
                    </div>
                    
                    <label>Type:</label>
                    <select onchange="updateActionType('${context}', ${idx}, this.value)">
                        ${Object.entries(actionTypes).map(([key, type]) => `
                            <option value="${key}" ${action.type === key ? 'selected' : ''}>${type.name}</option>
                        `).join('')}
                    </select>
                    
                    ${renderActionFields(action, context, idx)}
                </div>
            `).join('');
        }
        
        function renderActionFields(action, context, idx) {
            const type = actionTypes[action.type];
            if (!type) return '';
            
            return type.fields.map(field => {
                const value = action[field.name] || '';
                
                if (field.type === 'select') {
                    return `
                        <label>${field.label}:</label>
                        <select onchange="updateActionField('${context}', ${idx}, '${field.name}', this.value)">
                            ${field.options.map(opt => `
                                <option value="${opt}" ${value == opt ? 'selected' : ''}>${opt}</option>
                            `).join('')}
                        </select>
                    `;
                } else if (field.type === 'textarea') {
                    return `
                        <label>${field.label}:</label>
                        <textarea rows="3" onchange="updateActionField('${context}', ${idx}, '${field.name}', this.value)"
                                  placeholder="${field.placeholder || ''}">${value}</textarea>
                    `;
                } else if (field.type === 'number') {
                    return `
                        <label>${field.label}:</label>
                        <input type="number" value="${value}" 
                               onchange="updateActionField('${context}', ${idx}, '${field.name}', parseInt(this.value))"
                               placeholder="${field.placeholder || ''}">
                    `;
                } else {
                    return `
                        <label>${field.label}:</label>
                        <input type="text" value="${value}" 
                               onchange="updateActionField('${context}', ${idx}, '${field.name}', this.value)"
                               placeholder="${field.placeholder || ''}">
                    `;
                }
            }).join('');
        }
        
        // ===== FLOW PREVIEW =====
        function generateFlowPreview(node) {
            let preview = '';
            
            // For NPCs, show all responses
            if (node.type === 'npc' && node.responses) {
                preview += '<div style="color: #0ff; margin-bottom: 10px;">NPC Dialogue Flow:</div>';
                node.responses.slice().reverse().forEach((resp, idx) => {
                    const priority = node.responses.length - idx;
                    preview += `<div class="flow-node">`;
                    preview += `<div class="flow-condition">PRIORITY ${priority}</div>`;
                    
                    if (resp.conditions && resp.conditions.length > 0) {
                        preview += `<div class="flow-condition">IF: ${resp.conditions.map(formatCondition).join(' AND ')}</div>`;
                    }
                    
                    preview += `<div class="flow-text">SAY: "${resp.text}"</div>`;
                    
                    if (resp.actions && resp.actions.length > 0) {
                        resp.actions.forEach(action => {
                            preview += `<div class="flow-action">THEN: ${formatAction(action)}</div>`;
                        });
                    }
                    
                    preview += `</div>`;
                });
                return preview;
            }
            
            // For events
            if (node.conditions && node.conditions.length > 0) {
                preview += '<div class="flow-node"><div class="flow-condition">IF: ';
                preview += node.conditions.map(formatCondition).join(' AND ');
                preview += '</div></div>';
            }
            
            if (node.actions && node.actions.length > 0) {
                node.actions.forEach(action => {
                    preview += '<div class="flow-node"><div class="flow-action">THEN: ';
                    preview += formatAction(action);
                    preview += '</div></div>';
                });
            }
            
            if (node.oneShot) {
                const flagName = `${selectedNodeId}_completed`;
                preview += `<div class="flow-node"><div class="flow-action">FINALLY: Set flag.${flagName} = true</div></div>`;
            }
            
            return preview || '<div style="color: #555;">No flow to preview</div>';
        }
        
        function formatCondition(c) {
            if (c.type === 'flag') return `flag.${c.flagName} = ${c.shouldBe}`;
            if (c.type === 'map') return `map = ${c.mapId}`;
            if (c.type === 'day') return `day ${c.comparison} ${c.day}`;
            if (c.type === 'level') return `level ${c.comparison} ${c.level}`;
            if (c.type === 'position') return `pos = (${c.x}, ${c.y})`;
            if (c.type === 'hasItem') return `has ${c.itemId}`;
            return c.type;
        }
        
        function formatAction(a) {
            if (a.type === 'showMessage') return `Show "${a.message}"`;
            if (a.type === 'setFlag') return `Set flag.${a.flagName} = ${a.value}`;
            if (a.type === 'giveReward') return `Give ${a.gold}g, ${a.xp}xp`;
            if (a.type === 'spawnItem') return `Spawn ${a.itemId} at ${a.mapId}`;
            if (a.type === 'transport') return `Transport to ${a.mapId}`;
            if (a.type === 'addJournal') return `Journal: "${a.title}"`;
            if (a.type === 'customCode') return `Custom code`;
            return a.type;
        }
        
        // ===== UPDATE FUNCTIONS =====
        function updateNodeField(field, value) {
            const node = contentData.nodes[selectedNodeId];
            node[field] = value;
        }
        
        // Response management
        function addResponse() {
            const node = contentData.nodes[selectedNodeId];
            if (!node.responses) node.responses = [];
            node.responses.push({
                id: `resp_${node.responses.length}`,
                text: 'New dialogue...',
                conditions: [],
                actions: []
            });
            renderEditor();
        }
        
        function deleteResponse(idx) {
            const node = contentData.nodes[selectedNodeId];
            node.responses.splice(idx, 1);
            renderEditor();
        }
        
        function moveResponse(idx, direction) {
            const node = contentData.nodes[selectedNodeId];
            const newIdx = idx + direction;
            [node.responses[idx], node.responses[newIdx]] = 
                [node.responses[newIdx], node.responses[idx]];
            renderEditor();
        }
        
        function updateResponse(idx, field, value) {
            const node = contentData.nodes[selectedNodeId];
            node.responses[idx][field] = value;
        }
        
        // Condition/Action management
        function getConditionArray(context) {
            const node = contentData.nodes[selectedNodeId];
            if (context.startsWith('resp_')) {
                const respIdx = parseInt(context.split('_')[1]);
                return node.responses[respIdx].conditions;
            } else {
                return node.conditions;
            }
        }
        
        function getActionArray(context) {
            const node = contentData.nodes[selectedNodeId];
            if (context.startsWith('resp_')) {
                const respIdx = parseInt(context.split('_')[1]);
                return node.responses[respIdx].actions;
            } else {
                return node.actions;
            }
        }
        
        function addCondition(context) {
            const conditions = getConditionArray(context);
            conditions.push({ type: 'flag', flagName: '', shouldBe: 'true' });
            renderEditor();
        }
        
        function deleteCondition(context, idx) {
            const conditions = getConditionArray(context);
            conditions.splice(idx, 1);
            renderEditor();
        }
        
        function updateConditionType(context, idx, type) {
            const conditions = getConditionArray(context);
            conditions[idx] = { type: type };
            renderEditor();
        }
        
        function updateConditionField(context, idx, field, value) {
            const conditions = getConditionArray(context);
            conditions[idx][field] = value;
        }
        
        function addAction(context) {
            const actions = getActionArray(context);
            actions.push({ type: 'showMessage', message: '' });
            renderEditor();
        }
        
        function deleteAction(context, idx) {
            const actions = getActionArray(context);
            actions.splice(idx, 1);
            renderEditor();
        }
        
        function updateActionType(context, idx, type) {
            const actions = getActionArray(context);
            actions[idx] = { type: type };
            renderEditor();
        }
        
        function updateActionField(context, idx, field, value) {
            const actions = getActionArray(context);
            actions[idx][field] = value;
        }
        
        // ===== CODE GENERATION =====
        function downloadAll() {
            const dialogueJS = generateDialogueJS();
            const eventsJS = generateEventsJS();
            
            downloadFile('dialogue.js', dialogueJS);
            downloadFile('events.js', eventsJS);
            
            alert("âœ… DOWNLOADED 2 FILES!\n\n1. dialogue.js\n2. events.js\n\nReplace your old files and refresh the game!");
        }
        
        function generateDialogueJS() {
            const npcNodes = Object.entries(contentData.nodes)
                .filter(([id, node]) => node.type === 'npc');
            
            const database = {};
            npcNodes.forEach(([id, node]) => {
                database[id] = {
                    name: node.name,
                    sprite: node.sprite,
                    isShopkeeper: node.isShopkeeper,
                    lines: node.responses.map(resp => ({
                        text: resp.text,
                        requires: convertConditionsToRequires(resp.conditions),
                        sets: convertActionsToSets(resp.actions)
                    }))
                };
            });
            
            return `// dialogue.js - Generated by Unified Content Editor
console.log('=== DIALOGUE.JS IS LOADING ===');

const dialogueDatabase = ${JSON.stringify(database, null, 2)};

function getDialogue(npcId, gameState) {
    const npc = dialogueDatabase[npcId];
    if (!npc) {
        console.error('NPC "' + npcId + '" not found');
        return { text: "...", sets: null };
    }
    
    if (!gameState.flags) gameState.flags = {};
    
    for (let i = npc.lines.length - 1; i >= 0; i--) {
        const line = npc.lines[i];
        if (meetsRequirements(line.requires, gameState)) {
            return processDialogue(line, gameState, npcId);
        }
    }
    
    return processDialogue(npc.lines[0], gameState, npcId);
}

function meetsRequirements(requires, gameState) {
    if (!requires) return true;
    
    if (requires.level !== undefined && gameState.player.level < requires.level) return false;
    if (requires.gold !== undefined && gameState.player.gold < requires.gold) return false;
    if (requires.hasItem && !gameState.player.inventory.includes(requires.hasItem)) return false;
    
    if (requires.flags) {
        for (const [flag, requiredValue] of Object.entries(requires.flags)) {
            const currentValue = gameState.flags?.[flag];
            if (typeof requiredValue === 'boolean') {
                if (Boolean(currentValue) !== requiredValue) return false;
            } else if (currentValue !== requiredValue) {
                return false;
            }
        }
    }
    
    return true;
}

function processDialogue(line, gameState, npcId) {
    if (line.sets) {
        if (!gameState.flags) gameState.flags = {};
        Object.assign(gameState.flags, line.sets);
    }
    
    return {
        text: line.text,
        sets: line.sets || null,
        npcName: dialogueDatabase[npcId]?.name || "Unknown"
    };
}

function getNPCData(npcId) {
    return dialogueDatabase[npcId] || null;
}

console.log('=== DIALOGUE.JS LOADED ===');
console.log('Loaded ' + Object.keys(dialogueDatabase).length + ' NPCs');`;
        }
        
        function generateEventsJS() {
            const eventNodes = Object.entries(contentData.nodes)
                .filter(([id, node]) => node.type === 'event');
            
            const handlers = eventNodes.map(([id, node]) => {
                const flagName = `${id}_completed`;
                
                return `    '${id}': {
        // ${node.description || 'No description'}
        canTrigger: (gs) => {
            ${node.oneShot ? `if (gs.flags.${flagName}) return false;` : ''}
            return ${generateConditionCode(node.conditions)};
        },
        
        onTrigger: (gs) => {
            console.log('EVENT: ${id}');
            ${generateActionCode(node.actions)}
            ${node.oneShot ? `gs.flags.${flagName} = true;` : ''}
        }
    }`;
            }).join(',\n\n');
            
            return `// events.js - Generated by Unified Content Editor
console.log('=== EVENTS.JS IS LOADING ===');

const eventHandlers = {
${handlers}
};

function checkEvents(gameState) {
    Object.entries(eventHandlers).forEach(([eventId, handler]) => {
        try {
            if (handler.canTrigger(gameState)) {
                console.log(\`Triggering event: \${eventId}\`);
                handler.onTrigger(gameState);
            }
        } catch (error) {
            console.error(\`Error in event \${eventId}:\`, error);
        }
    });
}

// ===== REST HOOK SYSTEM =====
const restHooks = {
    beforeRest: [],
    afterRest: []
};

function runBeforeRestHooks(gameState, location) {
    for (const hook of restHooks.beforeRest) {
        try {
            const shouldCancel = hook(gameState, location);
            if (shouldCancel) {
                console.log('Rest cancelled by hook');
                return true;
            }
        } catch (error) {
            console.error('Error in beforeRest hook:', error);
        }
    }
    return false;
}

function runAfterRestHooks(gameState, location) {
    restHooks.afterRest.forEach(hook => {
        try {
            hook(gameState, location);
        } catch (error) {
            console.error('Error in afterRest hook:', error);
        }
    });
}

console.log('=== EVENTS.JS LOADED ===');
console.log(\`Registered \${Object.keys(eventHandlers).length} event handlers\`);`;
        }
        
        function convertConditionsToRequires(conditions) {
            if (!conditions || conditions.length === 0) return {};
            
            const requires = {};
            const flags = {};
            
            conditions.forEach(c => {
                if (c.type === 'flag') {
                    flags[c.flagName] = c.shouldBe === 'true' || c.shouldBe === true;
                } else if (c.type === 'level') {
                    requires.level = c.level;
                } else if (c.type === 'hasItem') {
                    requires.hasItem = c.itemId;
                } else if (c.type === 'gold') {
                    requires.gold = c.amount;
                }
            });
            
            if (Object.keys(flags).length > 0) requires.flags = flags;
            return requires;
        }
        
        function convertActionsToSets(actions) {
            if (!actions || actions.length === 0) return {};
            
            const sets = {};
            actions.forEach(a => {
                if (a.type === 'setFlag') {
                    sets[a.flagName] = a.value === 'true' || a.value === true;
                }
            });
            
            return sets;
        }
        
        function generateConditionCode(conditions) {
            if (!conditions || conditions.length === 0) return 'true';
            
            const code = conditions.map(c => {
                if (c.type === 'flag') {
                    return `gs.flags.${c.flagName} === ${c.shouldBe}`;
                } else if (c.type === 'map') {
                    return `gs.currentMap === '${c.mapId}'`;
                } else if (c.type === 'day') {
                    return `gs.dayCounter ${c.comparison} ${c.day}`;
                } else if (c.type === 'level') {
                    return `gs.player.level ${c.comparison} ${c.level}`;
                } else if (c.type === 'position') {
                    let str = `gs.player.x === ${c.x} && gs.player.y === ${c.y}`;
                    if (c.mapId) str += ` && gs.currentMap === '${c.mapId}'`;
                    return str;
                } else if (c.type === 'hasItem') {
                    return `gs.player.inventory.includes('${c.itemId}')`;
                } else if (c.type === 'gold') {
                    return `gs.player.gold ${c.comparison} ${c.amount}`;
                }
                return 'true';
            });
            
            return code.join(' &&\n                   ');
        }
        
        function generateActionCode(actions) {
            if (!actions || actions.length === 0) return '// No actions';
            
            return actions.map(a => {
                if (a.type === 'showMessage') {
                    const color = a.color ? `, CGA.${a.color}` : '';
                    return `addMessage("${a.message}"${color});`;
                } else if (a.type === 'setFlag') {
                    return `gs.flags.${a.flagName} = ${a.value};`;
                } else if (a.type === 'giveReward') {
                    let code = '';
                    if (a.gold > 0) code += `gs.player.gold += ${a.gold}; addMessage("+${a.gold} gold!", CGA.CYAN);`;
                    if (a.xp > 0) code += ` gs.player.xp += ${a.xp}; checkLevelUp();`;
                    if (a.itemId) code += ` gs.player.inventory.push('${a.itemId}');`;
                    return code;
                } else if (a.type === 'spawnItem') {
                    return `
            const location = '${a.x},${a.y}';
            if (!treasureContents['${a.mapId}']) treasureContents['${a.mapId}'] = {};
            treasureContents['${a.mapId}'][location] = { gold: 0, items: ['${a.itemId}'] };
            const [x, y] = location.split(',').map(Number);
            const row = gs.world.tiles[y];
            gs.world.tiles[y] = row.substring(0, x) + '$' + row.substring(x + 1);
            renderWorld();`;
                } else if (a.type === 'transport') {
                    return `loadMap('${a.mapId}'); gs.player.x = ${a.x}; gs.player.y = ${a.y};`;
                } else if (a.type === 'addJournal') {
                    return `addJournalEntry('${a.title}', [{ type: 'text', content: '${a.content.replace(/'/g, "\\'")}' }]);`;
                } else if (a.type === 'customCode') {
                    return a.code || '// Empty custom code';
                }
                return '// Unknown action';
            }).join('\n            ');
        }
        
        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/javascript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // ===== IMPORT/EXPORT =====
        function exportJSON() {
            const json = JSON.stringify(contentData, null, 2);
            document.getElementById('exportArea').value = json;
            
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'content_data.json';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function importJSON() {
            const json = document.getElementById('exportArea').value;
            if (!json.trim()) {
                alert("Paste JSON into the text area first!");
                return;
            }
            
            try {
                contentData = JSON.parse(json);
                selectedNodeId = null;
                renderNodeList();
                document.getElementById('editorArea').innerHTML = '<div class="empty-state">Data imported! Select a node to edit.</div>';
                alert("Content imported successfully!");
            } catch (e) {
                alert("Invalid JSON: " + e.message);
            }
        }
        
        // Initialize
        init();
    </script>
</body>
</html>